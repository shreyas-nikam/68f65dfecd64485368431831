import pytest
import pandas as pd
from definition_7969140f1e93419fbe9d970e9f909494 import generate_synthetic_data

# Define the set of columns expected to be generated by the function
EXPECTED_COLUMNS = [
    'timestamp', 'entity_id', 'numeric_feature_A', 'numeric_feature_B',
    'categorical_feature', 'gene_expression_level', 'tissue_type'
]

@pytest.mark.parametrize(
    "num_rows, start_date, num_categories, expected_rows, expected_exception, check_categories_count",
    [
        # Test Case 1: Standard valid inputs - ensures basic functionality and DataFrame structure
        (10, '2023-01-01', 3, 10, None, None),
        # Test Case 2: Edge case - num_rows is zero - expects an empty DataFrame with correct columns
        (0, '2023-01-01', 2, 0, None, None),
        # Test Case 3: Edge case - num_categories is one - ensures categorical features handle single value correctly
        (5, '2023-01-15', 1, 5, None, 1),
        # Test Case 4: Invalid start_date format - expects a ValueError from date parsing
        (10, 'not-a-valid-date', 2, None, ValueError, None),
        # Test Case 5: Invalid num_rows type (e.g., string instead of int) - expects a TypeError
        ('invalid_type', '2023-01-01', 2, None, TypeError, None),
    ]
)
def test_generate_synthetic_data(num_rows, start_date, num_categories, expected_rows, expected_exception, check_categories_count):
    df = None # Initialize df to None

    try:
        df = generate_synthetic_data(num_rows, start_date, num_categories)

        # If an exception was expected but none was raised, this test should fail
        assert expected_exception is None, \
            f"Expected {expected_exception.__name__} but no exception was raised."

        # Assertions for successful DataFrame generation
        assert isinstance(df, pd.DataFrame), \
            "Output is not a pandas DataFrame."
        assert len(df) == expected_rows, \
            f"Expected {expected_rows} rows but got {len(df)}."
        assert all(col in df.columns for col in EXPECTED_COLUMNS), \
            "Not all expected columns are present in the DataFrame."
        assert len(df.columns) == len(EXPECTED_COLUMNS), \
            "DataFrame contains unexpected number of columns."


        if expected_rows > 0:
            # Basic type checks for non-empty DataFrame
            assert pd.api.types.is_datetime64_any_dtype(df['timestamp']), "timestamp column is not datetime type."
            assert pd.api.types.is_integer_dtype(df['entity_id']), "entity_id column is not integer type."
            assert pd.api.types.is_float_dtype(df['numeric_feature_A']), "numeric_feature_A column is not float type."
            assert pd.api.types.is_string_dtype(df['categorical_feature']) or df['categorical_feature'].dtype == 'category', \
                "categorical_feature column is not string/category type."
            assert pd.api.types.is_string_dtype(df['tissue_type']) or df['tissue_type'].dtype == 'category', \
                "tissue_type column is not string/category type."

            # Specific check for num_categories = 1 case
            if check_categories_count is not None:
                assert df['categorical_feature'].nunique() == check_categories_count, \
                    f"Expected {check_categories_count} unique categorical features, but got {df['categorical_feature'].nunique()}."
                assert df['tissue_type'].nunique() == check_categories_count, \
                    f"Expected {check_categories_count} unique tissue types, but got {df['tissue_type'].nunique()}."

    except Exception as e:
        # If an exception was not expected but one was raised, this test should fail
        assert expected_exception is not None, \
            f"An unexpected exception {type(e).__name__} was raised: {e}"
        # Assert that the raised exception is of the expected type
        assert isinstance(e, expected_exception), \
            f"Expected exception type {expected_exception.__name__} but got {type(e).__name__}: {e}"
